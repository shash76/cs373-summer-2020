Factorial.py and FactorialT.py
------------------------------
Factorial.py:
------------
factorial_recursion
•	Perform recursive calls first, then take the return value of 
the recursive call and calculate the result.  The result won't 
be calculated until you have returned from every recursive call.
•	You need to keep stack frames until the recursion is over 
-- O(n) space. 

factorial_tail_recursion
•	Note that a function inside a function is allowed in Python. 
•	Perform your calculations first and then execute the 
recursive call, passing the results of the current step to 
the next recursive step. 
•	We are reusing the current stack frame so we will never get stack overflow.
•	Some compliers transfer tail recursive functions into loop (but not in Python).
•	Procedure is recursive but the process is not.

FactorialT.py:
------------
with self.subTest(): if one of the test fails, this would be 
the end of test_0. with keeps the test going until it goes through all. 

timeit:
•	timeit function takes three arguments.
•	f.__name__ obtains the name of the current function and "(100)" is the argument to the function.
•	"from __main__ import " + f.__name__ imports the definition of the function
•	number = 1000, determine how many times we are going to run the function.
•	The result, t, is printed after multiply it with 1000 because timeit provides results in microseconds 
and we need it in milliseconds.

Reduce.py:
---------
reduce:
------
- reduce is a higher order function. it takes a function 
  as one of its argument.
- mul is a function from a module called operator. 
  You can think of it as a wrapper for the operator '*'.
- reduce(binary_function, sequence_of_elements[, Seed: base_case_if_seq_is_empty)]

- Note that the initialization is optional. If it's present, 
  it will be placed before the items of the iterable in the calculations. 
  if it's not, and the iterable contain one item, it will return this one item.

  reduce_for_range (bf, a, v) demands a to be indexable.
  reduce_for (bf, a, v) does NOT demand a to indexable. It should only be iterable.
 
  reduce(add,[],0] #0
  reduce(add,[])
  error: no initial value

  e.g., reduce(mul, range(1, 4), 1)
  1*1*2*3
  e.g., reduce(add, range(1,5), 1) = 1 + 1 + 2 + 3 + 4 

  write the function reduce: reduce(bf, iterable, seed) 


- reduce_for_range (bf, a, v) :
  demands "a" to be indexable

- reduce_for (bf, a, v) :
  demands "a" to be an iterable

- reduce_while (bf, a, v) :
  receives an iterable and generates an iterator
-------------


iteration.py: 
------------
Iterables:
- an iterable is an object that you can iterate through.
- iterables usually have the property "__getitem__" 
  that indicates an object is indexable.

>>> x=[2, 3, 4]
>>> hasattr(x, "__iter__")
True
>>> hasattr(x, "__getitem__")
True
>>> hasattr(x, "__next__")
False

Iterators vs generators:
- an iterator object is an object that has the "__iter__" and "__next__" attribute.
- you can get an iterator out of an iterable using iter function.
- generator functions allow you to declare a function that behaves like an iterator, 
  i.e. it can be used in a for loop.
- every generator is an iterator.

iter(): takes an iterable object and returns an iterator.
>>> x=[2, 3, 4]
>>> p = iter(x)
>>> next(p)
2
>>> next(p)
3
>>> next(p)
4
>>> next(p)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration
>>>
-----
Notes:
1. len(x) == 0 can be used if x is a list but not on any iterable object.
 
b = iter([1,2,3]) # b is both an iterator and an iterable.
len(b) # TypeError: object of type 'list_iterator' has no len()

2. Testing if an iterable is empty does not always work 
for iterables.

>>> x = iter([])
>>> if x == []:
...    print("Empty")
... else :
...    print("Full")
...
Full

3. list(iterable) == [] works for all finite iterable objects 
but won't work for infinite iterable objects 
(such as in count or repeat).

Generators:
----------

yield:
------
Yield:
e.g., 1
>>>def f() :
>>>    print("abc")
>>>    return 5
>>>    print ("def") # it does not make sense to have code 
                     # after return unless there is a condition before return.

>>>v = f()
abc
>>>print(v)
5
-------------------------------
e.g., 2
>>>def f() :
>>>    print("abc")
>>>    yield 5
>>>    print("def")
>>>    yield 6

>>>v = f()
>>>print(v)
<generator object f at 0x0096E8A0>
>>>print(hasattr(v, "__next__"))
True
>>>w = next(v)
abc
>>>print(w)
5
>>>w = next(v) # function starts running from where it left off
def
>>>print(w)
6
>>> w = next(v) # raises an exception
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration
>>>print(w)
6
------------------------------------------

>>>def f () :
>>>	print("abc")
>>>	yield 5
>>>	print("def")
>>>	yield 6
>>>	print("ghi")

>>>v = f()     # <nothing>
>>>print(v)    
<generator object f at .....>
>>>w = next(v) 
abc
>>>print(w)    
5
>>>x = next(v) 
def
>>>print(x)   
6
>>>y = next(v) 
ghi 
raise StopIteration
---------

Example of a Generator
# f.py
def yrange(n):
	i = 0
	while i < n :
		yield i
		i += 1
		
>>> from f import yrange
>>> yrange(3)
<generator object yrange at 0x01ABEA80>
>>> list(yrange(3))
[0, 1, 2]
>>>
------------------------------------------------------

Lambda and zip
--------------
Lambda is an anonymous function that can be created at runtime. 
Anonymous means that it should not be bound to a name.

>>> def f (x):
...     return x**2
>>> g = lambda x: x**2
>>>
>>> f(3) == g(3)
True
Note that the lambda definition does not include a "return" statement -- 
it always contains an expression which is returned.

Syntax:
lambda arg1, arg2, ...argN : expression using arguments
>>> f = lambda x, y, z: x + y + z
>>> f(1, 2, 3)
6
>>>

Zip:
zip is a generator that combines two objects in a tuple.

>>> a = [1, 2, 3, 4]
>>> b = ['a', 'b', 'c', 'd']
>>> c = zip(a, b)
>>> c
<zip object at 0x01939440>
>>> list(c)
[(1, 'a'), (2, 'b'), (3, 'c'), (4, 'd')]
>>> list(c)
[]

Comprehensions.py
-----------------
filter(predicate, list_of_inputs)
filter is a generator takes a predicate, it applies the predicate 
on the given iterable returns the element that satisfies the predicate.
It's an iterator, i.e., it returns itself.


"|=" union of sets

Lines 174: all() # all(iterable): Return True if all elements of the iterable are true (or if the iterable is empty).
A(): instance of a class
True
...
all([]) = True

Lines 186: any() # any(iterable): Return True if any element of the iterable is true. If the iterable is empty, return False.
any([]) = False
https://docs.python.org/3.5/library/functions.html#all